import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { bedrockClient, s3Client } from './aws-config';

const S3_BUCKET = process.env.S3_BUCKET_MEALS || 'scuzi-meals';

interface GenerateImageParams {
  mealName: string;
  description?: string;
  mealType: string;
  ingredients?: any[];
}

export async function generateMealImage({ 
  mealName, 
  description, 
  mealType, 
  ingredients 
}: GenerateImageParams): Promise<string | null> {
  try {
    // Create a detailed prompt for the meal image
    const ingredientsList = ingredients?.map(ing => 
      typeof ing === 'string' ? ing : ing.name
    ).join(', ') || '';
    
    const prompt = `A professional, appetizing photo of ${mealName}, a ${mealType} dish. ${description || ''} ${ingredientsList ? `Made with ${ingredientsList}.` : ''} The image should be well-lit, restaurant-quality food photography with vibrant colors and appealing presentation. High resolution, clean background, focus on the food.`;

    // Prepare the request for AWS Titan Image Generator G1 v2
    const titanRequest = {
      taskType: "TEXT_IMAGE",
      textToImageParams: {
        text: prompt,
        negativeText: "blurry, low quality, dark, unappetizing, messy, dirty, cartoon, illustration",
      },
      imageGenerationConfig: {
        numberOfImages: 1,
        height: 1024,
        width: 1024,
        cfgScale: 7.5,
        seed: Math.floor(Math.random() * 1000000),
      },
    };

    console.log(`ðŸŽ¨ Generating image for: ${mealName}`);

    // Call AWS Bedrock Titan Image Generator
    const command = new InvokeModelCommand({
      modelId: 'amazon.titan-image-generator-v2:0',
      body: JSON.stringify(titanRequest),
      contentType: 'application/json',
      accept: 'application/json',
    });

    const response = await bedrockClient.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));

    if (!responseBody.images || responseBody.images.length === 0) {
      console.error('No images generated by Titan');
      return null;
    }

    // Get the base64 image data
    const imageBase64 = responseBody.images[0];
    const imageBuffer = Buffer.from(imageBase64, 'base64');

    // Generate a unique filename
    const timestamp = Date.now();
    const sanitizedMealName = mealName.toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    const fileName = `meals/${sanitizedMealName}-${timestamp}.png`;

    // Upload to S3
    const uploadCommand = new PutObjectCommand({
      Bucket: S3_BUCKET,
      Key: fileName,
      Body: imageBuffer,
      ContentType: 'image/png',
      CacheControl: 'max-age=31536000', // 1 year cache
    });

    await s3Client.send(uploadCommand);

    // Return the S3 URL
    const imageUrl = `https://${S3_BUCKET}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${fileName}`;
    
    console.log(`âœ… Image generated and uploaded: ${imageUrl}`);
    return imageUrl;

  } catch (error) {
    console.error('Error generating meal image:', error);
    return null;
  }
}

export async function generateImagesForMeals(mealIds: number[]): Promise<{ success: number; failed: number; results: any[] }> {
  const results = {
    success: 0,
    failed: 0,
    results: [] as any[],
  };

  // Import here to avoid circular dependencies
  const { db } = await import('@/db/mysql-connection');
  const { meals } = await import('@/db/mysql-schema');
  const { eq, inArray } = await import('drizzle-orm');

  try {
    // Get meals that need images
    const mealsToProcess = await db.select()
      .from(meals)
      .where(inArray(meals.id, mealIds));

    console.log(`ðŸŽ¨ Starting image generation for ${mealsToProcess.length} meals`);

    for (const meal of mealsToProcess) {
      try {
        // Skip if image already exists
        if (meal.imageUrl) {
          console.log(`â­ï¸ Skipping ${meal.mealName} - image already exists`);
          results.results.push({
            mealId: meal.id,
            mealName: meal.mealName,
            status: 'skipped',
            imageUrl: meal.imageUrl,
          });
          continue;
        }

        // Generate image
        const imageUrl = await generateMealImage({
          mealName: meal.mealName,
          description: meal.tagline || undefined,
          mealType: meal.mealType,
          ingredients: meal.ingredients as any[],
        });

        if (imageUrl) {
          // Update meal with image URL
          await db.update(meals)
            .set({ 
              imageUrl,
              updatedAt: new Date(),
            })
            .where(eq(meals.id, meal.id));

          results.success++;
          results.results.push({
            mealId: meal.id,
            mealName: meal.mealName,
            status: 'success',
            imageUrl,
          });

          console.log(`âœ… Generated image for: ${meal.mealName}`);
        } else {
          results.failed++;
          results.results.push({
            mealId: meal.id,
            mealName: meal.mealName,
            status: 'failed',
            error: 'Image generation failed',
          });

          console.error(`âŒ Failed to generate image for: ${meal.mealName}`);
        }

        // Add a small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));

      } catch (error) {
        console.error(`Error processing meal ${meal.mealName}:`, error);
        results.failed++;
        results.results.push({
          mealId: meal.id,
          mealName: meal.mealName,
          status: 'error',
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    console.log(`ðŸŽ¨ Image generation complete: ${results.success} success, ${results.failed} failed`);
    return results;

  } catch (error) {
    console.error('Error in batch image generation:', error);
    throw error;
  }
}